### 第五章 继承

**继承**已存在的类就是复用（继承）这些类的方法和域。

**反射**是指在程序运行期间发现更多的类及其属性的能力。

#### 5.1 类、超类和子类

##### 5.1.1 定义子类

extends表示继承。

##### 5.1.2 覆盖方法

新的方法来覆盖（override）超类中的方法。

子类的方法不能够直接地访问超类的私有域。

在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。

##### 5.1.3 子类构造器

super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。

一个对象变量（例如，变量e）可以指示**多种实际类型**的现象被称为**多态（polymorphism）**。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。

##### 5.1.4 继承层次

由一个公共超类派生出来的所有类的集合被称为**继承层次（inheritance hierarchy）**。

Java不支持多继承。有关Java中多继承功能的实现方式，通过接口来实现的。

##### 5.1.5 多态

“is-a”规则，用来判断是否应该设计为继承关系的简单规则。

置换法则，它表明程序中出现超类对象的任何地方都可以用子类对象置换。

##### 5.1.6 理解方法调用

对象上应用方法调用

![方法调用图解](方法调用图解02.png)



动态绑定有一个**非常重要的特性**：无需对现存的代码进行修改，就可以对程序进行扩展。



在覆盖一个方法的时候，**子类方法不能低于超类方法的可见性**。特别是，如果超类方法是public，子类方法一定要声明为public。

在声明子类方法的时候，遗漏了public修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

##### 5.1.7 阻止继承：final类和方法

不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。

类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。

如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为**内联（inlining）**。

如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个方法进行内联处理。

##### 5.1.8 强制类型转换

进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。

在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。

只要没有捕获ClassCastException异常，程序就会终止执行。在一般情况下，**应该尽量少用**类型转换和instanceof运算符。