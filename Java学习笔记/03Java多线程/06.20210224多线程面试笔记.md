### 06.20210224多线程面试笔记

#### 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我 们不能直接调⽤ run() ⽅法？

线程的执行流程应该是start()方法线程进入runnable状态,获得CPU执行切片的时候,执行run()方法。

如果直接调用run方法，就相当于调用普通方法一样，不会以多线程的方式执行。



#### 说⼀说⾃⼰对于 synchronized 关键字的了解

synchronized解决了多个线程之间访问资源的同步性，synchronized可以保证被修饰的方法或者代码块，任意时刻只有一个线程执行。

java1.6之前的synchronized，属于重量级锁，性能消耗大。因为synchronized使用monitor是依赖底层的操作系统Mutex Lock来实现的,Java 线程是映射到操作系统的原生线程上,如果要挂起或者唤醒一个线程,都需要操作系统帮忙完成。操作系统需要从用户态转换到内核态来切换线程，这个转换需要比较长的时间。

java1.6优化后的synchronized，通过偏向锁，自旋锁，锁消除，锁粗化，轻量级锁来减少锁操作的开销。

所以现在synchronized可以满足绝大部分的需求。



